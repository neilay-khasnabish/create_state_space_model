# -*- coding: utf-8 -*-
"""create-state-space-model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uaIKKtLycnkwE2ZC62jwG4IfT1IS6hpc

# Create Discrete State Space Model. This script estimates the papameter matrices of State Stapce models.

![SS.gif](data:image/gif;base64,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)
"""

# Calling libraries
import numpy as np
from scipy.optimize import minimize
from scipy import linalg
import matplotlib.pyplot as plt

# Creating the class
class cssm :
  def __init__(self, A, B, C, u, y):
      self.A = A
      self.B = B
      self.C = C
      self.u = u
      self.y = y

  # Create the matrices
  def createMat(self, x) :
    # Extract parameters for A matrix
    A1 = x[0 : self.A[0]*self.A[1]]
    # Extract parameters for B matrix
    B1 = x[self.A[0]*self.A[1] : self.A[0]*self.A[1] + self.B[0]*self.B[1]]
    # Extract parameters for C matrix
    C1 = x[self.A[0]*self.A[1] + self.B[0]*self.B[1] : self.A[0]*self.A[1] + self.B[0]*self.B[1] + self.C[0]*self.C[1]]

    # Reshape the matrices
    A1 = np.reshape(A1, (self.A[0], self.A[1])) # No of states X No of states
    B1 = np.reshape(B1, (self.B[0], self.B[1])) # No of states X No of inputs
    C1 = np.reshape(C1, (self.C[0], self.C[1])) # No of outputs X No of states
    return A1, B1, C1

  # Creating the objective function
  def objFcn(self, x, flag = 0) :
    # Get the matrices after reshaping them
    A1, B1, C1 = self.createMat(x)
    
    # Creating initial state as 0
    [r_s, c_s] = np.shape(A1)
    x=np.zeros((r_s,1))

    # For reshaping the input
    [r_s, c_s] = np.shape(B1)

    # Creating a copy of output
    y_p = self.y.copy()
    [r_op, c_op] = np.shape(y_p)

    # Expanding through time
    for i in range(r_op) :
      y_p[i] = np.transpose(np.matmul(C1,x)) # Updating the predicted values
      x = np.matmul(A1,x) + np.matmul(B1,self.u[i].reshape(c_s,1)) #x[k+1]

    # Plotting only the first OP
    if flag == 1:
      [rr, cc] = np.shape(np.matmul(C1,x))
      for iPlot in range(rr) :
        plt.plot(self.y[:,0], label='Ref OP')
        plt.plot(y_p[:,0], label='Estimated OP')
        plt.ylabel('Output value')
        plt.title('Estimated output: ' + str(iPlot))
        plt.legend(loc="upper right")
        plt.show()
      print('Eigen values of the Estimated System matrix: ', linalg.eigvals(A1))

    # Returning the error
    errVal = np.mean(np.abs(y - y_p))
    return(errVal)

  # Initialise function
  def optimizeMdl(self, ite1=100) :
    # Create a placeholder
    totalsizeParams = self.A[0]*self.A[1] + self.B[0]*self.B[1] + self.C[0]*self.C[1]
    valDummy = 1000000000000.00

    # Random sampling
    print('Random sampling starts with Iteration', ite1)
    for iRand in range(ite1):
      # sigma * np.random.randn(...) + mu
      xDummy = np.random.randn(1, totalsizeParams) # sigma = 1 and mu = 1
      xAccpeted = xDummy[0,:]
      if self.objFcn(x = xDummy[0,:]) < valDummy:
        valDummy = self.objFcn(x = xDummy[0,:])
        xAccpeted = xDummy[0,:]
    print('Best initial guess with residual error: ', valDummy)

    # Optimize
    print('Optimization starts ...')
    x0 = xAccpeted
    res = minimize(self.objFcn, x0, method='nelder-mead', options={'xatol': 1e-8, 'disp': True})

    # Final residual error
    print('Residual error is: ')
    print(self.objFcn(x = res.x))

    # Validation : to be edited >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    self.objFcn(x = res.x, flag = 1)

    # Returning the matrices
    return(self.createMat(x = res.x))



# Inital validation of script

# Time on
import time
start = time.time()

# Define the shapes of system matrices as global variables
A = [2,2] # No of states X No of states
B = [2,1] # No of states X No of inputs
C = [1,2] # No of outputs X No of states

# Create dummy data having 100 data points
u = np.ones((100, 1)) # Samples X No of inputs
y = np.ones((100, 1)) # Samples X No of outputs
a_mat = np.array([[-0.2, -0.01],[0.03, 0]])
b_mat = np.array([[10],[0]])
c_mat = np.array([0, 1])
print('The defined matrices are:')
print(a_mat)
print(b_mat)
print(c_mat)
x=np.zeros((2,1))
for i in range(100):
  y[i] = np.matmul(c_mat,x) # Updating the predicted values
  x = np.matmul(a_mat,x) + np.matmul(b_mat,u[i]).reshape(2,1) #x[k+1]
# Show the data
plt.figure()
plt.plot(y)
plt.title('Steady state parameterisation dataset')
plt.ylabel('Output value')
plt.show()
print('Eigen values of Actual System matrix: ', linalg.eigvals(a_mat))
print('=============================================================')

# Creating the model
ssm = cssm(A, B, C, u, y)
A1, B1, C1 = ssm.optimizeMdl(ite1=1000)
print('The estimated matrices are:')
print(A1)
print(B1)
print(C1)

# Time off
end = time.time()
print('Total time elapsed: ', end - start)